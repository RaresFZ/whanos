<?xml version='1.1' encoding='UTF-8'?>
<project>
  <description>Creates a new Whanos CI/CD job for a given Git repository</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>REPOSITORY_URL</name>
          <description>Git repository URL (e.g., https://github.com/user/repo.git)</description>
          <defaultValue></defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>REPOSITORY_NAME</name>
          <description>Friendly name for the repository (will be used as job name)</description>
          <defaultValue></defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>BRANCH</name>
          <description>Git branch to monitor (default: main)</description>
          <defaultValue>main</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>CREDENTIALS_ID</name>
          <description>Jenkins credentials ID for private repositories (leave empty for public repos)</description>
          <defaultValue></defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <scm class="hudson.scm.NullSCM"/>
  <canRoam>true</canRoam>
  <disabled>false</disabled>
  <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
  <triggers/>
  <concurrentBuild>false</concurrentBuild>
  <builders>
    <javaposse.jobdsl.plugin.ExecuteDslScripts plugin="job-dsl">
      <targets>create_project_job.groovy</targets>
      <usingScriptText>true</usingScriptText>
      <scriptText><![CDATA[
def repoUrl = binding.variables['REPOSITORY_URL'] ?: ''
def repoName = binding.variables['REPOSITORY_NAME'] ?: ''
def branch = binding.variables['BRANCH'] ?: 'main'
def credentialsId = binding.variables['CREDENTIALS_ID'] ?: ''

if (!repoUrl || !repoName) {
    throw new IllegalArgumentException('REPOSITORY_URL and REPOSITORY_NAME are required')
}

// Sanitize job name - replace underscores and invalid chars with dashes for Kubernetes compatibility
def jobName = repoName.replaceAll(/[^A-Za-z0-9-]/, '-').toLowerCase()

folder('Projects') {
    description('Whanos project builds')
}

// Build credentials part conditionally
def credentialsPart = credentialsId ? ", credentialsId: '\${credentialsId}'" : ''

pipelineJob("Projects/${jobName}") {
    description("Whanos CI/CD for ${repoUrl}")
    
    parameters {
        stringParam('REGISTRY_HOST', '{{ registry_hostname | default("registry.whanos.example.com") }}', 'Docker registry host')
    }
    
    triggers {
        scm('* * * * *') // Poll SCM every minute
    }
    
    definition {
        cps {
            script("""
pipeline {
    agent any
    
    environment {
        REGISTRY_HOST = 'localhost:5000'
        K8S_REGISTRY_HOST = 'whanos-registry:5000'
        REGISTRY_USER = '{{ registry_username | default("ci") }}'
        REGISTRY_PASS = '{{ registry_password | default("changeme") }}'
        KUBECONFIG = '/var/lib/jenkins/.kube/config'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout([
                    \$class: 'GitSCM',
                    branches: [[name: '${branch}']],
                    userRemoteConfigs: [[
                        url: '${repoUrl}'${credentialsPart}
                    ]]
                ])
            }
        }
        
        stage('Detect Language') {
            steps {
                script {
                    if (fileExists('Makefile')) {
                        env.LANGUAGE = 'c'
                    } else if (fileExists('pom.xml')) {
                        env.LANGUAGE = 'java'
                    } else if (fileExists('package.json')) {
                        env.LANGUAGE = 'javascript'
                    } else if (fileExists('requirements.txt')) {
                        env.LANGUAGE = 'python'
                    } else if (fileExists('app/main.bf')) {
                        env.LANGUAGE = 'befunge'
                    } else {
                        error('No supported language detected in repository')
                    }
                    echo "Detected language: \${env.LANGUAGE}"
                }
            }
        }
        
        stage('Build Image') {
            steps {
                script {
                    // Use localhost:5000 for pushing from Jenkins host
                    def imageName = "localhost:5000/${jobName}:\${env.BUILD_NUMBER}"
                    // Use whanos-registry:5000 for pulling from k8s pods
                    def k8sImageName = "whanos-registry:5000/${jobName}:\${env.BUILD_NUMBER}"
                    
                    if (fileExists('Dockerfile')) {
                        // Custom Dockerfile exists - user wants to customize the base image
                        sh "docker build -t \${imageName} ."
                    } else {
                        // No custom Dockerfile - use standalone Whanos image from local copy
                        sh \"\"\"
                            docker build -t \${imageName} -f /var/lib/jenkins/whanos-images/\${env.LANGUAGE}/Dockerfile.standalone .
                        \"\"\"
                    }
                    
                    env.IMAGE_NAME = imageName
                    env.K8S_IMAGE_NAME = k8sImageName
                }
            }
        }
        
        stage('Push Image') {
            steps {
                script {
                    sh \"\"\"
                        echo "\${env.REGISTRY_PASS}" | docker login -u "\${env.REGISTRY_USER}" --password-stdin localhost:5000
                        docker push "\${env.IMAGE_NAME}"
                        docker logout localhost:5000
                    \"\"\"
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            when {
                expression { fileExists('whanos.yml') }
            }
            steps {
                script {
                    // Ensure we're using the k3d cluster context
                    sh 'kubectl config use-context k3d-whanos || true'
                    
                    // Parse whanos.yml using shell commands
                    def replicas = sh(script: 'grep -E "^  replicas:" whanos.yml | cut -d: -f2 | tr -d " " || echo "1"', returnStdout: true).trim()
                    def ports = sh(script: 'grep -A 10 "^  ports:" whanos.yml | grep -E "^    - " | sed "s/^    - //" | tr "\\\\n" "," || echo ""', returnStdout: true).trim()
                    
                    // Generate basic deployment manifest
                    def manifestLines = [
                        "apiVersion: apps/v1",
                        "kind: Deployment",
                        "metadata:",
                        "  name: ${jobName}",
                        "  namespace: whanos-cicd",
                        "spec:",
                        "  replicas: " + replicas,
                        "  selector:",
                        "    matchLabels:",
                        "      app: ${jobName}",
                        "  template:",
                        "    metadata:",
                        "      labels:",
                        "        app: ${jobName}",
                        "    spec:",
                        "      imagePullSecrets:",
                        "        - name: registry-credentials",
                        "      containers:",
                        "        - name: ${jobName}",
                        "          image: " + env.K8S_IMAGE_NAME,
                        "          imagePullPolicy: Always"
                    ]
                    
                    // Add ports if any
                    if (ports) {
                        manifestLines << "          ports:"
                        ports.split(',').findAll { it }.each { port ->
                            manifestLines << "            - containerPort: " + port.trim()
                        }
                    }
                    
                    // Check for resource requests/limits
                    def hasResources = sh(script: 'grep -q "^  resources:" whanos.yml && echo "true" || echo "false"', returnStdout: true).trim()
                    if (hasResources == 'true') {
                        manifestLines << "          resources:"
                        
                        def hasRequests = sh(script: 'grep -q "^    requests:" whanos.yml && echo "true" || echo "false"', returnStdout: true).trim()
                        if (hasRequests == 'true') {
                            def memReq = sh(script: 'grep -A 5 "^    requests:" whanos.yml | grep "memory:" | head -1 | cut -d: -f2 | tr -d " \\\\"" || echo ""', returnStdout: true).trim()
                            def cpuReq = sh(script: 'grep -A 5 "^    requests:" whanos.yml | grep "cpu:" | head -1 | cut -d: -f2 | tr -d " \\\\"" || echo ""', returnStdout: true).trim()
                            
                            if (memReq || cpuReq) {
                                manifestLines << "            requests:"
                                if (memReq) manifestLines << "              memory: " + memReq
                                if (cpuReq) manifestLines << "              cpu: " + cpuReq
                            }
                        }
                        
                        def hasLimits = sh(script: 'grep -q "^    limits:" whanos.yml && echo "true" || echo "false"', returnStdout: true).trim()
                        if (hasLimits == 'true') {
                            def memLim = sh(script: 'grep -A 5 "^    limits:" whanos.yml | grep "memory:" | head -1 | cut -d: -f2 | tr -d " \\\\"" || echo ""', returnStdout: true).trim()
                            def cpuLim = sh(script: 'grep -A 5 "^    limits:" whanos.yml | grep "cpu:" | head -1 | cut -d: -f2 | tr -d " \\\\"" || echo ""', returnStdout: true).trim()
                            
                            if (memLim || cpuLim) {
                                manifestLines << "            limits:"
                                if (memLim) manifestLines << "              memory: " + memLim
                                if (cpuLim) manifestLines << "              cpu: " + cpuLim
                            }
                        }
                    }
                    
                    def manifest = manifestLines.join('\\n') + '\\n'
                    
                    // Apply deployment
                    writeFile file: 'deployment.yaml', text: manifest
                    sh 'kubectl apply --validate=false -f deployment.yaml -n whanos-cicd'
                    
                    // Create service if ports exist
                    if (ports) {
                        def serviceLines = [
                            "apiVersion: v1",
                            "kind: Service",
                            "metadata:",
                            "  name: ${jobName}",
                            "  namespace: whanos-cicd",
                            "spec:",
                            "  type: ClusterIP",
                            "  selector:",
                            "    app: ${jobName}",
                            "  ports:"
                        ]
                        ports.split(',').findAll { it }.each { port ->
                            def p = port.trim()
                            serviceLines << "    - port: " + p
                            serviceLines << "      targetPort: " + p
                            serviceLines << "      protocol: TCP"
                            serviceLines << "      name: port-" + p
                        }
                        
                        def serviceManifest = serviceLines.join('\\n') + '\\n'
                        
                        writeFile file: 'service.yaml', text: serviceManifest
                        sh 'kubectl apply --validate=false -f service.yaml -n whanos-cicd'
                        
                        // Check if Traefik CRDs are available
                        def traefikAvailable = sh(
                            script: 'kubectl get crd middlewares.traefik.containo.us 2>/dev/null',
                            returnStatus: true
                        ) == 0
                        
                        if (traefikAvailable) {
                            // Create Traefik Middleware for path prefix stripping
                            def middlewareLines = [
                                "apiVersion: traefik.containo.us/v1alpha1",
                                "kind: Middleware",
                                "metadata:",
                                "  name: ${jobName}-stripprefix",
                                "  namespace: whanos-cicd",
                                "spec:",
                                "  stripPrefix:",
                                "    prefixes:",
                                "      - /${jobName}"
                            ]
                            def middlewareManifest = middlewareLines.join('\\n') + '\\n'
                            
                            writeFile file: 'middleware.yaml', text: middlewareManifest
                            sh 'kubectl apply --validate=false -f middleware.yaml -n whanos-cicd'
                            
                            // Create Ingress for external access with Traefik
                            def firstPort = ports.split(',').findAll { it }[0].trim()
                            def ingressLines = [
                                "apiVersion: networking.k8s.io/v1",
                                "kind: Ingress",
                                "metadata:",
                                "  name: ${jobName}",
                                "  namespace: whanos-cicd",
                                "  annotations:",
                                "    traefik.ingress.kubernetes.io/router.entrypoints: web",
                                "    traefik.ingress.kubernetes.io/router.middlewares: whanos-cicd-${jobName}-stripprefix@kubernetescrd",
                                "spec:",
                                "  rules:",
                                "    - http:",
                                "        paths:",
                                "          - path: /${jobName}",
                                "            pathType: Prefix",
                                "            backend:",
                                "              service:",
                                "                name: ${jobName}",
                                "                port:",
                                "                  number: " + firstPort
                            ]
                            
                            def ingressManifest = ingressLines.join('\\n') + '\\n'
                            
                            writeFile file: 'ingress.yaml', text: ingressManifest
                            sh 'kubectl delete ingress ${jobName} -n whanos-cicd --ignore-not-found=true'
                            sh 'kubectl apply --validate=false -f ingress.yaml -n whanos-cicd'
                            
                            echo "Application accessible at: http://localhost:8081/${jobName}"
                        } else {
                            // Fallback to NodePort if Traefik is not available
                            echo "WARNING: Traefik CRDs not found, using NodePort service instead"
                            sh 'kubectl patch svc ${jobName} -n whanos-cicd -p "{\\\\"spec\\\\":{\\\\"type\\\\":\\\\"NodePort\\\\"}}"'
                            
                            sh 'sleep 2'
                            def nodePort = sh(script: "kubectl get svc ${jobName} -n whanos-cicd -o jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()
                            echo "Application accessible at NodePort: \${nodePort}"
                            echo "Access via: http://localhost:\${nodePort}"
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            deleteDir()
        }
    }
}
            """)
            sandbox(true)
        }
    }
}
      ]]></scriptText>
      <ignoreExisting>false</ignoreExisting>
      <ignoreMissingFiles>false</ignoreMissingFiles>
      <failOnMissingPlugin>false</failOnMissingPlugin>
      <failOnSeedCollision>false</failOnSeedCollision>
      <unstableOnDeprecation>false</unstableOnDeprecation>
      <removedJobAction>IGNORE</removedJobAction>
      <removedViewAction>IGNORE</removedViewAction>
      <removedConfigFilesAction>IGNORE</removedConfigFilesAction>
      <lookupStrategy>JENKINS_ROOT</lookupStrategy>
    </javaposse.jobdsl.plugin.ExecuteDslScripts>
  </builders>
  <publishers/>
  <buildWrappers/>
</project>
